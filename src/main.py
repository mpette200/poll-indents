from dataclasses import dataclass, fields, asdict
from datetime import datetime, timezone
from google.cloud import datastore


@dataclass(frozen=True)
class NewVote:
    """
    Data to input when casting a new vote.
    This is basically the same as Vote, but without the unique id
    and timestamp which will be assigned by the DataModel.

    Parameters:
    voted_for - either "Vote_compact" or "Vote_long"
    layout_seen - "C_first" if compact was shown first or "L_first"
                  if long was shown first
    screen_dims - string of form "width x height"
    """
    voted_for: str
    layout_seen: str
    screen_dims: str
    VCOMPACT = "Vote_compact"
    VLONG = "Vote_long"
    VALID_VOTES = [VCOMPACT, VLONG]
    VALID_LAYOUTS = ["C_first", "L_first"]

    def validate(self):
        assert self.voted_for in NewVote.VALID_VOTES
        assert self.layout_seen in NewVote.VALID_LAYOUTS


@dataclass(frozen=True, slots=True)
class Vote:
    """
    Immutable voting data including unique id and timestamp.
    """
    key: tuple[str, str]
    layout_seen: str
    screen_dims: str
    timestamp: datetime


@dataclass(frozen=True, slots=True)
class CountVotes:
    """
    Immutable count of total votes
    """
    count_vote_compact: int
    count_vote_long: int
    COMPACT = "count_vote_compact"
    LONG = "count_vote_long"


class DataModel:
    """
    Datamodel that connects to google-cloud-datastore database
    """
    PROJECT = "mp-indents-01"
    TOTAL_KEY = ("Votes", "totals")

    def __init__(self) -> None:
        self.client = datastore.Client(project=DataModel.PROJECT)
        self.totals_key = self.client.key(*DataModel.TOTAL_KEY)

    def create_initial_count(self) -> str:
        totals = datastore.Entity(self.totals_key)
        for f in fields(CountVotes):
            totals[f.name] = 0
        self.client.put(totals, timeout=5)
        return str(totals)

    def submit_vote(self, vote: NewVote) -> Vote:
        """
        Submit a vote and store in the database.
        Returns the vote info together with its unique id and timestamp
        """
        # prepare data outside transaction for performance
        vote.validate()
        data = asdict(vote)
        del data["voted_for"]
        partial_key = self.client.key(vote.voted_for, parent=self.totals_key)
        record = datastore.Entity(partial_key)
        record.update(data)
        timestamp = datetime.now(timezone.utc)
        record["timestamp"] = timestamp

        # store totals separately
        if vote.voted_for == vote.VCOMPACT:
            name = CountVotes.COMPACT
        elif vote.voted_for == vote.VLONG:
            name = CountVotes.LONG
        else:
            raise ValueError(f"invalid voted_for: {vote.voted_for}")

        with self.client.transaction():
            totals = self.client.get(self.totals_key)
            totals[name] += 1
            # need a transaction, not enough to use put_multi()
            self.client.put_multi([record, totals], timeout=5)

        # unique id not generated by database until after transaction closed
        return Vote(
            (record.key.kind, record.key.id),
            **record
        )

    def get_count(self) -> CountVotes:
        totals = self.client.get(self.totals_key)
        return CountVotes(
            count_vote_compact=totals[CountVotes.COMPACT],
            count_vote_long=totals[CountVotes.LONG]
        )
