from dataclasses import dataclass
from datetime import datetime, timezone
from google.cloud import datastore


class NewVote:
    """
    Data to input when casting a new vote.
    This is basically the same as Vote, but without the unique id
    and timestamp which will be assigned by the DataModel.

    Parameters:
    voted_for - either "Compact" or "Long"
    layout_seen - "C_first" if compact was shown first or "L_first"
                  if long was shown first
    screen_dims - string of form "width x height"
    """
    voted_for: str
    data: dict[str, str]

    def __init__(self,
                 voted_for: str,
                 layout_seen: str,
                 screen_dims: str) -> None:
        self.voted_for = voted_for
        self.data = {
            "layout_seen": layout_seen,
            "screen_dims": screen_dims
        }


@dataclass(frozen=True, slots=True)
class Vote:
    """
    Immutable voting data including unique id and timestamp.
    """
    key: tuple[str, str]
    layout_seen: str
    screen_dims: str
    timestamp: datetime


@dataclass(frozen=True, slots=True)
class CountVotes:
    """
    Immutable count of total votes
    """
    count_voted_compact: int
    count_voted_long: int


def isvalid_vote_for(name: str) -> bool:
    return name in [
        "Compact",
        "Long"
    ]


def isvalid_layout_seen(name: str) -> bool:
    return name in [
        "C_first",
        "L_first"
    ]


class DataModel:
    """
    Datamodel that connects to google-cloud-datastore database
    """
    client: datastore.Client
    property_count_compact = "count_vote_compact"
    property_count_long = "count_vote_long"
    kind_compact = "Vote_compact"
    kind_long = "Vote_long"
    key_map = {
        "Compact": kind_compact,
        "Long": kind_long
    }

    def __init__(self) -> None:
        self.client = datastore.Client(project="mp-indents-01")
        self.totals_key = self.client.key("Votes", "totals")

    def create_initial_count(self) -> str:
        totals = datastore.Entity(self.totals_key)
        totals[DataModel.property_count_compact] = 0
        totals[DataModel.property_count_long] = 0
        self.client.put(totals, timeout=5)
        return str(totals)

    def submit_vote(self, vote: NewVote) -> Vote:
        """
        Submit a vote and store in the database.
        Returns the vote info together with its unique id and timestamp
        """
        # prepare data outside transaction for performance
        voted_for = DataModel.key_map[vote.voted_for]
        partial_key = self.client.key(voted_for, "Votes", "totals")
        record = datastore.Entity(partial_key)
        record.update(vote.data)
        timestamp = datetime.now(timezone.utc)
        record["timestamp"] = timestamp

        # store totals separately
        if voted_for == DataModel.kind_compact:
            name = DataModel.property_count_compact
        elif voted_for == DataModel.kind_long:
            name = DataModel.property_count_long
        else:
            raise ValueError(f"invalid voted_for: {voted_for}")

        with self.client.transaction():
            totals = self.client.get(self.totals_key)
            totals[name] += 1
            # need a transaction, not enough to use put_multi()
            self.client.put_multi([record, totals], timeout=5)

        # unique id not generated by database until after transaction closed
        record_id = record.key.name
        return Vote(
            (voted_for, record_id),
            vote.data["layout_seen"],
            vote.data["screen_dims"],
            timestamp
        )

    def get_count(self) -> CountVotes:
        totals = self.client.get(self.totals_key)
        return CountVotes(
            count_voted_compact=totals[DataModel.property_count_compact],
            count_voted_long=totals[DataModel.property_count_long]
        )
